\documentclass[a4wide, 11pt]{article}
\usepackage{a4, fullpage}
\usepackage[margin=2.5cm]{geometry}
\newcommand{\tx}{\texttt}

\begin{document}
\title{Pintos Task 3 : Virtual Memory}
\author{Francesco Di Mauro, Thomas Rooney, Alex Rozanski}

\maketitle

\section{Page Table Management}
\subsection{Data structures - A1}
\subsubsection{Data referring to the Supplemental Page Table}

Added to \tx{struct thread} in \tx{thread.h}:
\begin{verbatim}
struct hash supplemental_page_table;
\end{verbatim}
Hash table representing the supplemental page table. \\\\
Added to new file \tx{page.h}:
\begin{verbatim}
enum page_status {
   PAGE_UNDEFINED = 0,           /*default status*/
   PAGE_FILESYS = 1 << 0,        /*page referring to a file*/
   PAGE_SWAP  = 1 << 1,          /*page in the swap partition*/
   PAGE_MEMORY_MAPPED  = 1 << 2, /*page representing a mem mapd file*/
   PAGE_IN_MEMORY = 1 << 3,      /*page currently stored in memory*/
   PAGE_ZERO = 1 << 4,           /*page of zero bytes*/
};
\end{verbatim}
Enum used to represent the status of a page in the supplemental page table.

\begin{verbatim}
struct page_filesys_info {
   struct file *file;
   size_t offset;
};
\end{verbatim}
If a page refers to a file in the file system, this struct will store information regarding the actual file in memory.


\begin{verbatim}
struct page {
   struct hash_elem hash_elem;   	/* Used to store the frame in the page table. */
   void *vaddr;                   /* The address of the page in user virtual memory. */
   void *aux;	               					    /* A pointer to auxiliary data */
   enum page_status page_status;  /* Used to store the page's current status. */
   bool writable;					                /* Stores if a page is writable or not */
};
\end{verbatim}
Struct holding information about a page stored in the supplemental page table.

\subsubsection{Data referring to the Frame Table}

Added to the new file \tx{frame.h}:
\begin{verbatim}
struct hash frame\_table;
\end{verbatim}
System wide hash table representing the Frame Table.

\begin{verbatim}
struct frame {
   struct hash_elem hash_elem;		   /* Used to store the frame in the frame table. */
   int32_t frame_addr;				           /* The address of the frame in memory.*/
   struct page *page;				            /* Stores the page mapped into this frame*/
   tid_t owner_id;						               /* Stores the tid of the owning thread*/
   int32_t unused_count;          /*Represents how many times the frame was not evicted*/
};
\end{verbatim}



\subsection{Algorithms}
\subsubsection{A2}
The location of a frame is handled mainly via the supplemental page table.
When an executable is loaded, the new function \tx{load\_executable\_page} is called. This function will take care of analysing the content of the segment that should be loaded, and instead of bringing it directly into memory, thus allocating a frame, it will add a mapping to the supplemental page table. This is carried out by initialising a \tx{struct page}, storing the virtual address of the page to be mapped and   setting the field \tx{page\_status} to one of the statues in the \tx{enum page\_status}, depending on the nature of the segment. \\
Upon page fault, the supplemental page table is consulted: if an entry is not present, the OS decides whether it is a memory access that requires a stack growth, otherwise the memory access is invalid. But if an entry is found, then, at first, the function \tx{frame\_allocator\_get\_user\_page} is called. This function will, in turn, call \tx{palloc\_get\_page}, which will retrieve a frame from the user pool, add a page table entry for this page - frame mapping in the page table, and return the page's address. The additional work that \tx{frame\_allocator\_get\_user\_page} carries out is to create a \tx{struct frame}, recording the address of the allocated frame, the address of the page  mapped, the \tx{tid\_t} of the thread owning the frame, and then adding this struct to the frame table. The frame will then be filled with the correct information: it will be zeroed, or the content of a file in the file system will be copied \\
Before returning from the page fault handler, the page will me marked as present in memory in the supplemental page table.
\subsubsection{A3}

In our pseudo LRU page eviction algorithm, we prioritize eviction of non-dirty and non-accessed pages, and reset those bits on each call, whilst maintaining a counter which considers the number of time's it's been dirty or accessed while the frame is mapped to a given page. Thus when we don't need to coordinate these accessed and dirty bits, because when we consider them we always have the user virtual addresses present. Thus we avoid the issue entirely.

\subsection{Synchronization}
\subsubsection{A4}
The initial implementation of synchronisation for frame allocation comprised of a lock around any access to the frame table, handled  by the functions \tx{frame\_map} and \tx{frame\_unmap}. These function are responsible for adding and removing mapping in the frame table. \\
However, while implementing eviction, the group noted that this form of synchronisation, limited only to the access to the frame table, was not enough in order to prevent races. More specifically, since the frame table modification is the last step in the algorithm for eviction, the need to prevent threads from trying to request frames during eviction arose. Therefore, the whole action of requesting and allocating a frame is now atomical, thanks to the presence of a \tx{frame\_allocation\_lock}.
\subsection{Rationale}
\subsubsection{A5}
When dealing with data storage using data structures in Pintos, the use of a hash table is almost an immediate choice. Using a hash table both for the supplemental page table and the frame table allows us to perform insertion, deletion and lookups very easily, while also being a memory efficient solution. Early design included a bitmap associated to the frame table, used in order to performs look-ups even faster, and to choose a frame for eviction very efficiently. However, in the end the idea was abandoned because, despite having some advantages, the frame unmapping operations became time confusing, since two data structures needed modification in order to represent the fact that a frame was not mapped any more. \\
Another important advantage of a hash table, compared to a linked  list, is that resource reclamation upon process exit was very trivial to implement. Hash tables, in fact, provide a method for destruction which take as a parameter a function pointer: this function will be called onto every  element present in the table when freeing it. Exploiting this feature in the supplemental page table destruction, choosing a course of action for each specific page status was trivial: the \tx{supplemental\_page\_table\_destroy\_func} , for example, will remove from the frame table all the frames that the exiting thread held in memory.

\section{Paging to and from disk}

\subsection{Data structures}
\subsubsection{B1}

Added to new file \tx{swap.h}:
\begin{verbatim}

/* Stores if a block is in use or not, and the location of that block */
struct swap_entry {
   block_sector_t block;
   bool in_use;
};
\end{verbatim}

Added to new file \tx{swap.c}:
\begin{verbatim}

/* The number of sectors in a page. */
#define PAGE_NUM_SECTORS PGSIZE / BLOCK_SECTOR_SIZE 

/* Swap Block Pointer - points to the block dedicated to swap on the filesystem */
static struct block *swap_block; 

/* Size of the Swap Block in bytes */
static size_t swap_size;

/* Number of pages that will fit into the Swap block */
static size_t max_pages;         

/* Global lock to stop concurrent access of the swap table. */
static struct lock swap_lock;        

/* The Swap Table Array */
static struct swap_entry *swap_table;

/* The Size of the Swap Table in bytes */
static size_t swap_table_size;
\end{verbatim}


\subsection{Algorithms}
\subsubsection{B2}
The choice of a suitable frame to evict is implemented via a pseudo-Least Recently Used algorithm.\\
 When the pool of user frame is empty, more specifically when a call to \tx{palloc\_get\_page(PAL\_USER)} returns \tx{NULL}, the frame eviction algorithm kicks in. \\The algorithm will run through all the frames present in the frame table, checking their \tx{unused\_count} field. 
 
 

\subsubsection{B3}
After having chosen a candidate frame for eviction, the function \tx{frame\_allocator\_save\_frame} is called: this function will decide whether to write back the changes made to a page on the file it came from, or else, save it to the swap partition. After this operation is carried out, the frame is removed from the owner's page table, and set as \tx{PAGE\_IN\_SWAP}, in the owner's supplemental page table. So the data belonging to Q which referred to the frame are correctly modified.
\begin{itemize}
\item Avoid writing to swap clean pages which refers to files (Don't know if tom is already doing that)
\end{itemize}  
In order to properly set up P's information on the new frame, the function \tx{palloc\_get\_page} will be called again. This might seem a very inefficient move, but it allows us to properly reset the information about the frame, since during eviction, it was also deleted from the bitmap representing the user's frame pool.\\
The page is then installed in P's page directory,   


\subsection{B4}

To decide if a virtual address is invalid, or need's the stack to grow, we pass it through this function:
\begin{verbatim}
-- In exception.h
/* Maximum Stack Size: 8 megabytes*/
#define MAX_STACK_SIZE 8388608

-- In exception.c
bool
is_in_vstack(void *ptr, uint32_t *esp)
{
  return  ((PHYS_BASE - pg_round_down (ptr)) <= MAX_STACK_SIZE
           && (uint32_t*)ptr >= (esp - 32));
}
\end{verbatim}

We consider a pointer to be in the ``virtual stack'', when it is between the bottom of the stack and the top. This is done by first checking if the difference between \tx{PHYS\_BASE} and the pointer's page directory, is less (or equal to) the maximum stack.\\
\\
We also consider that the given pointer is greater than 32 bytes lower than esp. This is because the furthest page fault from esp which requires page growth, is that which is caused by the assembly \tx{PUSHA} instruction. This can be seen in the test \tx{pt-grow-pusha}

\begin{verbatim}
     "pushal;"                   /* Push 32 bytes on stack at once. */
\end{verbatim}

\subsection{Synchronization}
\subsubsection{B5}

The Frame Table and the Swap Table are global, hence we have global locks to control access to these two tables. These are invoked to ensure that every access and wriet of the frame and swap table are atomic.\\
\\
The supplemental page table is only accessed by the given process, but it is also referred to when we evict a page, because we need to update the references to where the evicted page is now located.\\
\\
Because of this, we chose an implementation where the supplemental page table has no locks, because when we only evict a page when we are recovering from a page fault, and need a new page of memory and there is a lack of frames available.



\subsubsection{B6}

\subsubsection{B7}

\subsubsection{B8}
Paged out pages which need to be brought in memory need a special treatment when dealing with system calls, and, most importantly, the \tx{read} system call. This is because the actual action of reading into the a user specified buffer could cause a page fault which could not be properly handled. In order to avoid this problem, a different strategy has been implemented: The provided buffer is still validated but, if it page faults because the stack needs to grow to allow space for the data, the stack growth is carried out before the reading. This way, we avoid having to deal with the page fault that could potentially occur while reading.  

\subsection{Rationale}
\subsubsection{B9}


\section{Memory Mapped Files}
\subsection{Data structures}
\subsubsection{C1}
\begin{verbatim}
struct page_mmap_info {
   mapid_t mapping;				/* The mmap() mapid. */
   size_t offset;					/* The offset into the file. */
   size_t length;					/* The number of bytes of the file stored in this page. */
};
\end{verbatim}
If a page represents a file mapped in memory, this struct will hold information about the id of the mapping, offset in the file and length of the file.

\subsection{Algorithms}
\subsubsection{C2}

When a file is memory-mapped, we determine how many pages worth of memory are used by the file, then for every page we add an entry to the supplemental page table (starting from the user virtual address that the file is to be mapped from).

The information about each page that is added to the supplemental page table is stored in a \tx{struct page}. For each a memory-mapped page that we add to the supplemental page table, we allocate a \tx{page\_mmap\_info} struct which contains members for the mapid (which is the value returned by \tx{mmap()}), the offset into the file that's been memory mapped for the current page, and the length of memory-mapped file from the offset that this page contains (this will likely be \tx{PGSIZE} but will be less for the last page of the memory-mapped file if the file is not a multiple of \tx{PGSIZE}).

We then set the \tx{aux} member of the \tx{struct page} to point to this new \tx{struct page\_mmap\_info}, and the \tx{page\_status} to be \tx{PAGE\_MEMORY\_MAPPED} to denote that this is a page for a memory-mapped file.

The page faulting process for a memory-mapped file page is similar to that for an executable page in that we load data from the filesystem into the frame allocated for the page of memory. However, when we load in a page-worth of memory-mapped file, we have to look up the memory mapping in the thread's memory map table (the \tx{mmap\_table} member of \tx{struct thread}). From this, we can get the \tx{struct file} pointer for the file that has been mapped into the user virtual address space, and then read the chunk of data from disk. This is different to how we deal with executable pages, as each \tx{struct page}'s \tx{aux} member points to a \tx{struct page\_filesys\_info} which contains the underlying \tx{struct file} pointer directly. Since we want to be able to access the memory-map info via the mmap id for each memory-mapped page, we only store the mmap id and not the \tx{struct file} pointer directly. We can look up the \tx{struct file} from the entry in the \tx{mmap\_table} and get the file pointer from here. Storing the file pointer in each \tx{struct page\_mmap\_info} would be unnecessary duplication and could lead to data inconsistency.

\subsubsection{C3}

The \tx{mmap()} system call is called with the user virtual address that the file should be mapped to in memory. In \tx{mmap\_handler()} in \tx{syscall.c} (which implements the behaviour for \tx{mmap()}) we first determine the number of pages that the memory-mapped file will span over, then we iterate over every page address for the memory-mapped file starting from the address the file should be mapped from. For each address, we check the supplemental page table for whether a page is already being used at this user virtual address. If a page entry exists in the supplemental page table for any of these page addresses, it denotes that the memory-mapped file would overwrite an existing memory segment, and so we return \tx{-1} to indicate that the memory-mapping failed.

\subsection{Rationale}
\subsubsection{C4}

We do not share much of the code for the two situations, because even though their implementations are both shared in that they demand-page their data from disk and write their data back to disk, we have abstracted how we handle different types of data in the supplemental page table, such that it wouldn't make sense to share much of their implementation.

\end{document}