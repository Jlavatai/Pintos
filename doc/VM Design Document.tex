\documentclass[a4wide, 11pt]{article}
\usepackage{a4, fullpage}
\usepackage[margin=2.5cm]{geometry}
\newcommand{\tx}{\texttt}

\begin{document}
\title{Pintos Task 3 : Virtual Memory}
\author{Francesco Di Mauro, Thomas Rooney, Alex Rozanski}

\maketitle

\section{Page Table Management}
\subsection{Data structures}
\subsubsection{A1}
Added to \tx{struct thread} in \tx{thread.h}:
\begin{verbatim}
struct hash supplemental_page_table;
\end{verbatim}
Hash table representing the supplemental page table.
Added to new file \tx{page.h}:
\begin{verbatim}
enum page_status {
   PAGE_UNDEFINED = 0,           /*default status*/
   PAGE_FILESYS = 1 << 0,        /*page referring to a file*/
   PAGE_SWAP  = 1 << 1,          /*page in the swap partition*/
   PAGE_MEMORY_MAPPED  = 1 << 2, /*page representing a mem mapd file*/
   PAGE_IN_MEMORY = 1 << 3,      /*page currently stored in memory*/
   PAGE_ZERO = 1 << 4,           /*page of zero bytes*/
};
\end{verbatim}
Enum used to represent the status of a page in the supplemental page table.

\begin{verbatim}
struct page_filesys_info {
   struct file *file;
   size_t offset;
};
\end{verbatim}
If a page refers to a file in the file system, it will store info regarding the actual file in memory.


\begin{verbatim}
struct page {
   struct hash_elem hash_elem;		/* Used to store the frame in the page table. */
   void *vaddr;	    			/* The address of the page in user virtual memory. */
   void *aux;						/* */
   enum page_status page_status;   /* Used to store the page's current status. */
   bool writable;					/* Stores if a page is writable or not */
};
\end{verbatim}
Struct holding information about a page, stored in the supplemental page table.

\subsection{Algorithms}
\subsubsection{A2}
The location of a frame is handled mainly via the supplemental page table.
When an executable is loaded, the new function \tx{load\_executable\_page} is called. This function will take care of analysing the content of the segment that should be loaded, and instead of bringing it directly into memory, thus allocating a frame, it will add a mapping to the supplemental page table. This is carried out by initialising a \tx{struct page}, storing the virtual address of the page to be mapped and   setting the field \tx{page\_status} to one of the statues in the \tx{enum page\_status}, depending on the nature of the segment. \\
Upon page fault, the supplemental page table is consulted: if an entry is not present, the OS decides whether it is a memory access that requires a stack growth, otherwise the memory access is invalid. But if an entry is found, then, at first, the function \tx{frame\_allocator\_get\_user\_page} is called. This function will, in turn, call \tx{palloc\_get\_page}, which will retrieve a frame from the user pool, add a page table entry for this page - frame mapping in the page table, and return the page's address. The additional work that \tx{frame\_allocator\_get\_user\_page} carries out is to create a \tx{struct frame}, recording the address of the allocated frame, the address of the page  mapped, the \tx{tid\_t} of the thread owning the frame, and then adding this struct to the frame table. The frame will then be filled with the correct information: it will be zeroed, or the content of a file in the file system will be copied \\
Before returning from the page fault handler, the page will me marked as present in memory in the supplemental page table.
\subsubsection{A3}

In our pseudo LRU page eviction algorithm, we prioritize eviction of non-dirty and non-accessed pages, and reset those bits on each call, whilst maintaining a counter which considers the number of time's it's been dirty or accessed while the frame is mapped to a given page. Thus when we don't need to coordinate these accessed and dirty bits, because when we consider them we always have the user virtual addresses present. Thus we avoid the issue entirely.

\subsection{Synchronization}
\subsubsection{A4}
The initial implementation of synchronisation for frame allocation comprised of a lock around any access to the frame table, handled  by the functions \tx{frame\_map} and \tx{frame\_unmap}. These function are responsible for adding and removing mapping in the frame table. \\
However, while implementing eviction, the group noted that this form of synchronisation, limited only to the access to the frame table, was not enough in order to prevent races. More specifically, since the frame table modification is the last step in the algorithm for eviction, the need to prevent threads from trying to request frames during eviction arose. Therefore, the whole action of requesting and allocating a frame is now atomical, thanks to the presence of a \tx{frame\_allocation\_lock}.
\subsection{Rationale}
\subsubsection{A5}
When dealing with data storage using data structures in Pintos, the use of a hash table is almost an immediate choice. Using a hash table both for the supplemental page table and the frame table allows us to perform insertion, deletion and lookups very easily, while also being a memory efficient solution. Early design included a bitmap associated to the frame table, used in order to performs look-ups even faster, and to choose a frame for eviction very efficiently. However, in the end the idea was abandoned because, despite having some advantages, the frame unmapping operations became time confusing, since two data structures needed modification in order to represent the fact that a frame was not mapped any more. \\
Another important advantage of a hash table, compared to a linked  list, is that resource reclamation upon process exit was very trivial to implement. Hash tables, in fact, provide a method for destruction which take as a parameter a function pointer: this function will be called onto every  element present in the table when freeing it. Exploiting this feature in the supplemental page table destruction, choosing a course of action for each specific page status was trivial: the \tx{supplemental\_page\_table\_destroy\_func} , for example, will remove from the frame table all the frames that the exiting thread held in memory.

\section{Paging to and from disk}

\subsection{Data structures}
\subsubsection{B1}

\subsection{Algorithms}
\subsubsection{B2}
The choice of a suitable frame to evict is implemented via a pseudo-Least Recently Used algorithm.\\
 When the pool of user frame is empty, more specifically when a call to \tx{palloc\_get\_page(PAL\_USER)} returns \tx{NULL}, the frame eviction algorithm kicks in. \\The algorithm will run through all the frames present in the frame table, checking their \tx{unused\_count} field. 
 
 

\subsubsection{B3}
After having chosen a candidate frame for eviction, the function \tx{frame\_allocator\_save\_frame} is called: this function will decide whether to write back the changes made to a page on the file it came from, or else, save it to the swap partition. After this operation is carried out, the frame is removed from the owner's page table, and set as \tx{PAGE\_IN\_SWAP}, in the owner's supplemental page table. So the data belonging to Q which referred to the frame are correctly modified.
\begin{itemize}
\item Avoid writing to swap clean pages which refers to files (Don't know if tom is already doing that)
\end{itemize}  
In order to properly set up P's information on the new frame, the function \tx{palloc\_get\_page} will be called again. This might seem a very inefficient move, but it allows us to properly reset the information about the frame, since during eviction, it was also deleted from the bitmap representing the user's frame pool.\\
The page is then installed in P's page directory,   


\subsection{B4}

\subsection{Synchronization}
\subsubsection{B5}

\subsubsection{B6}

\subsubsection{B7}

\subsubsection{B8}

\subsection{Rationale}
\subsubsection{B9}


\section{Memory Mapped Files}
\subsection{Data structures}
\subsubsection{C1}
\begin{verbatim}
struct page_mmap_info {
   mapid_t mapping;				/* The mmap() mapid. */
   size_t offset;					/* The offset into the file. */
   size_t length;					/* The number of bytes of the file stored in this page. */
};
\end{verbatim}
If a page represents a file mapped in memory, this struct will hold information about the id of the mapping, offset in the file and length of the file.

\subsection{Algorithms}
\subsubsection{C2}

\subsubsection{C3}

The \tx{mmap()} system call is called with the user virtual address that the file should be mapped to in memory. In \tx{mmap\_handler()} in \tx{syscall.c} (which implements the behaviour for \tx{mmap()}) we first determine the number of pages that the memory-mapped file will span over, then we iterate over every page address for the memory-mapped file starting from the address the file should be mapped from. For each address, we check the supplemental page table for whether a page is already being used at this user virtual address. If a page entry exists in the supplemental page table for any of these page addresses, it denotes that the memory-mapped file would overwrite an existing memory segment, and so we return \tx{-1} to indicate that the memory-mapping failed.

\subsection{Rationale}
\subsubsection{C4}

\end{document}