\documentclass[a4wide, 11pt]{article}
\usepackage{a4, fullpage}
\usepackage[margin=2.5cm]{geometry}
\newcommand{\tx}{\texttt}

\begin{document}
\title{Pintos Task 3 : Virtual Memory}
\author{Francesco Di Mauro, Thomas Rooney, Alex Rozanski}

\maketitle

\section{Page Table Management}
\subsection{Data structures}
\subsubsection{A1}
Added to \tx{struct thread} in \tx{thread.h}:
\begin{verbatim}
struct hash supplemental_page_table;
\end{verbatim}
Hash table representing the supplemental page table.
Added to new file \tx{page.h}:
\begin{verbatim}
enum page_status {
   PAGE_UNDEFINED = 0,           /*default status*/
   PAGE_FILESYS = 1 << 0,        /*page referring to a file*/
   PAGE_SWAP  = 1 << 1,          /*page in the swap partition*/
   PAGE_MEMORY_MAPPED  = 1 << 2, /*page representing a mem mapd file*/
   PAGE_IN_MEMORY = 1 << 3,      /*page currently stored in memory*/
   PAGE_ZERO = 1 << 4,           /*page of zero bytes*/
};
\end{verbatim}
Enum used to represent the status of a page in the supplemental page table.

\begin{verbatim}
struct page_filesys_info {
   struct file *file;
   size_t offset;
};
\end{verbatim}
If a page refers to a file in the file system, it will store info regarding the actual file in memory.


\begin{verbatim}
struct page {
   struct hash_elem hash_elem;		/* Used to store the frame in the page table. */
   void *vaddr;	    			/* The address of the page in user virtual memory. */
   void *aux;						/* */
   enum page_status page_status;   /* Used to store the page's current status. */
   bool writable;					/* Stores if a page is writable or not */
};
\end{verbatim}
Struct holding information about a page, stored in the supplemental page table.

 

\subsection{Algorithms}
\subsubsection{A2}
The location of a frame is handled mainly via the supplemental page table.
When an executable is loaded, the new function \tx{load\_executable\_page} is called. This function will take care of analysing the content of the segment that should be loaded, and instead of bringing it directly into memory, thus allocating a frame, it adds a mapping in the supplemental page table. This is carried out by initialising a \tx{struct page}, storing the virtual address of the page to be mapped and   setting the field \tx{page\_status} to the status needed depending on the nature of the segment. \\
Upon page fault, the supplemental page table is consulted: if an entry is not present, the OS decides whether it is a memory access that requires a stack growth. But if an entry is found, then, at first, the function \tx{frame\_allocator\_get\_user\_page} is called. This function will, in turn, call \tx{palloc\_get\_page}, which will retrieve a frame from the user pool, add a page table entry for this page - frame mapping in the page table, and return the page's address. The additional work that \tx{frame\_allocator\_get\_user\_page} carries out is to create a \tx{struct frame}, recording the address of the allocated frame, the address of the page  mapped, the \tx{tid\_t} of the thread owning the frame, and then adding this struct to the frame table. The frame will then be filled with the correct information: it will be zeroed, or the content of a file in the file system will be copied \\
Before returning from the page fault handler, the page will me marked as present in memory in the supplemental page table.
\subsubsection{A3}

\subsection{Synchronization}
\subsubsection{A4}
The initial implementation of synchronisation for frame allocation comprised of a lock around any access to the frame table, more specifically in the functions \tx{frame\_map} and \tx{frame\_unmap}. These function are responsible for adding a mapping into the frame table. \\
However, while implementing eviction, the group noted that this could cause problem in a case where a thread tried to get a frame while another thread tries to swap in or out that specific frame. Therefore, the whole action of requesting and allocating a frame is now atomical.
\subsection{Rationale}
\subsubsection{A5}
When dealing with data storage using data structure in Pintos, the use of a hash table is almost an immediate choice. Using a hash table both for the supplemental page table and the frame table allows us to perform insertion, deletion and lookups very easily, while also being a memory efficient solution. Early design included a bitmap associated to the frame table, used in order to choose a frame more quickly for eviction, but in the end the idea was abandoned because, upon frame unmapping, two data structures would have needed modification. \\
Another important advantage of a hash table, compared to a linked  list, is that resource reclamation upon process exit was very trivial to implement. Hash tables, in fact, provide a method for destruction which take as a parameter a function pointer: this function will be called onto every  element present in the table. Exploiting this feature in the supplemental page table destruction, choosing a course of action for each specific page status was trivial: the \tx{supplemental\_page\_table\_destroy\_func} , for example, will remove from the frame table all the frames in which the pages mapped by the exiting process were mapped.

\section{Paging to and from disk}

\subsection{Data structures}
\subsubsection{B1}

\subsection{Algorithms}
\subsubsection{B2}
The choice of a suitable frame to evict is implemented via a pseudo-Least Recently Used algorithm.\\
 When the pool of user frame is empty, more specifically when a call to \tx{palloc\_get\_page(PAL\_USER)} returns \tx{NULL}, the frame eviction algorithm kicks in. The algorithm will run through all the frames present in the frame table, checking their \tx{unused\_count} field. 
 
 

\subsubsection{B3}
After having chosen a candidate frame for eviction, the function \tx{frame\_allocator\_save\_frame} is called: this function will decide whether to write back the changes made to a page on the file it came from, or else, save it to the swap partition. After this operation is carried out, the frame is removed from the owner's page table, and set as \tx{PAGE\_IN\_SWAP}, in the owner's supplemental page table. So the data belonging to Q which referred to the frame are correctly modified.
\begin{itemize}
\item Avoid writing to swap clean pages which refers to files (Don't know if tom is already doing that)
\end{itemize}  
In order to properly set up P's information on the new frame, the function \tx{palloc\_get\_page} will be called again. This might seem a very inefficient move, but it allows us to properly reset the information about the frame, since during eviction, it was also deleted from the bitmap representing the user's frame pool.\\
The page is then installed in P's page directory,   


\subsection{B4}

\subsection{Synchronization}
\subsubsection{B5}

\subsubsection{B6}

\subsubsection{B7}

\subsubsection{B8}

\subsection{Rationale}
\subsubsection{B9}


\section{Memory Mapped Files}
\subsection{Data structures}
\subsubsection{C1}
\begin{verbatim}
struct page_mmap_info {
   mapid_t mapping;				/* The mmap() mapid. */
   size_t offset;					/* The offset into the file. */
   size_t length;					/* The number of bytes of the file stored in this page. */
};
\end{verbatim}
If a page represents a file mapped in memory, this struct will hold information about the id of the mapping, offset in the file and length of the file.

\subsection{Algorithms}
\subsubsection{C2}

When a file is memory-mapped, we determine how many pages worth of memory are used by the file, then for every page we add an entry to the supplemental page table (starting from the user virtual address that the file is to be mapped from).

The information about each page that is added to the supplemental page table is stored in a \tx{struct page}. For each a memory-mapped page that we add to the supplemental page table, we allocate a \tx{page\_mmap\_info} struct which contains members for the mapid (which is the value returned by \tx{mmap()}), the offset into the file that's been memory mapped for the current page, and the length of memory-mapped file from the offset that this page contains (this will likely be \tx{PGSIZE} but will be less for the last page of the memory-mapped file if the file is not a multiple of \tx{PGSIZE}).

We then set the \tx{aux} member of the \tx{struct page} to point to this new \tx{struct page\_mmap\_info}, and the \tx{page\_status} to be \tx{PAGE\_MEMORY\_MAPPED} to denote that this is a page for a memory-mapped file.

The page faulting process for a memory-mapped file page is similar to that for an executable page in that we load data from the filesystem into the frame allocated for the page of memory. However, when we load in a page-worth of memory-mapped file, we have to look up the memory mapping in the thread's memory map table (the \tx{mmap\_table} member of \tx{struct thread}). From this, we can get the \tx{struct file} pointer for the file that has been mapped into the user virtual address space, and then read the chunk of data from disk. This is different to how we deal with executable pages, as each \tx{struct page}'s \tx{aux} member points to a \tx{struct page\_filesys\_info} which contains the underlying \tx{struct file} pointer directly. Since we want to be able to access the memory-map info via the mmap id for each memory-mapped page, we only store the mmap id and not the \tx{struct file} pointer directly. We can look up the \tx{struct file} from the entry in the \tx{mmap\_table} and get the file pointer from here. Storing the file pointer in each \tx{struct page\_mmap\_info} would be unnecessary duplication and could lead to data inconsistency.

\subsubsection{C3}

The \tx{mmap()} system call is called with the user virtual address that the file should be mapped to in memory. In \tx{mmap\_handler()} in \tx{syscall.c} (which implements the behaviour for \tx{mmap()}) we first determine the number of pages that the memory-mapped file will span over, then we iterate over every page address for the memory-mapped file starting from the address the file should be mapped from. For each address, we check the supplemental page table for whether a page is already being used at this user virtual address. If a page entry exists in the supplemental page table for any of these page addresses, it denotes that the memory-mapped file would overwrite an existing memory segment, and so we return \tx{-1} to indicate that the memory-mapping failed.

\subsection{Rationale}
\subsubsection{C4}

We do not share much of the code for the two situations, because even though their implementations are both shared in that they demand-page their data from disk and write their data back to disk, we have abstracted how we handle different types of data in the supplemental page table, such that it wouldn't make sense to share much of their implementation.

\end{document}