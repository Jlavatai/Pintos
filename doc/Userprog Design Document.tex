\documentclass[a4wide, 11pt]{article}
\usepackage{a4, fullpage}
\newcommand{\tab}{\hspace*{2em}}
\usepackage[margin=2cm]{geometry}
\newcommand{\tx}{\texttt}

\begin{document}

\title{OS 211 \\ Task2: User Programs \\ Design Document}
\author{Francesco Di Mauro, Thomas Rooney, Alex Rozanski}
\date{\today}
\maketitle

\section{Argument Passing}
\subsection{Data Structures}
\subsubsection{A1}
Added to \tx{process.c}:
\tab \begin{verbatim}
     struct argument
     {
         char *token;
         struct list_elem token_list_elem;
     };
\end{verbatim}
\tab The struct represent an argument, which \tx{char *token} is pointing to. This struct can be added in a list struct.
\\
\tab \begin{verbatim}
     struct stack_setup_data
     {
         struct list argv;
         int argc;
         struct argument **argument_ptrs;
     };
\end{verbatim}
This struct stores the data needed to setup the stack in \tx{start\_process}, namely a list of \tx{struct argument}, the number of arguments, and a list of pointer to \tx{struct argument}, used to free the memory at the end. 

\subsection{Algorithms}
\subsubsection{A2}
Argument parsing is split between the functions \tx{process\_execute} and \tx{start\_process}. \\
At the beginning of \tx{process\_execute}, a \tx{stack\_setup\_data} struct is instantiated, initializing the \tx{argv} list and setting \tx{argc} to zero. Afterwards, the file name passed as an argument to the pintos command is tokenized, and the pointers to the single tokens are stored into a \tx{struct argument}, and then added to the \tx{argv} list. Each struct is pushed at the front of the list, so that at the end the arguments will already be in reverse order, as needed. \\
The function \tx{start\_process}, will take care of pushing the arguments on the stack. As a first thing, it will save the pointer to the name of the process, which will be needed in order to free the memory page at the end of the stack setup. Then, after setting up the interrupt frame, it will iterate over the list of arguments a first time: in this first "pass", the string representing the arguments will be copied onto the stack, modifying the location \tx{esp} is pointing to depending on the length of the string. The iteration will be from the front to the end of the list, since the arguments are already in the opposite order. Moreover, the \tx{char} pointers pointing to the arguments in the heap, will be substituted with the location the \tx{esp} is pointing to. The function will then push a \tx{uint8\_t} as a word alignment, and a \tx{NULL} pointer, in order to respet the convention that \tx{argv[argc] = NULL}. Afterwards, the function will iterate over the same list again, this time pushing the pointers to the strings in the same (opposite) order. Finally, the pointer to the first argument will be pushed, followed by \tx{argc} and the "fake" return address. \\
Overflowing the stack is avoided by checking the esp value every time it is modified: if the difference between \tx{PHYS-BASE} and the current esp is bigger than 4KB, the process stops with an error code.   

\subsection{Rationale}
\subsubsection{A3}
The main difference between the functions \tx{strtok()} and \tx{strtok\_r()} is that the latter has an extra parameter, another \tx{char *}, which stores, after every tokenization, the pointer to the new location, to be used in the next call of the same function. the function \tx{strtok}, instead, stores the new location within an internal variable. Since Pintos might switch threads to run while this tokenization is taking place, the value of this internal variable would be lost, or could cause illegal memory accesses.
\subsubsection{A4}
A disadvantage of the Pintos method is that, before the tokenization, the command passed is copied into a memory page to avoid race conditions. This impose a 4KB limit on the command line, which is not present in UNIX. \\
Moreover, if something goes wrong  in the argument parsing in Pintos, the whole kernel would panic and interrupt the execution. Parsing the arguments at a higher stage allows to identify errors before they make the whole kernel crash.

\section{System Calls}
\subsection{Data Structures}
\subsubsection{B1}

\subsubsection{B2}

\subsection{Algorithms}
\subsubsection{B3}

\subsubsection{B4}

\subsubsection{B5}

\subsubsection{B6}

\subsection{Synchronisation}
\subsubsection{B7}

\subsubsection{B8}

\subsection{Rationale}
\subsubsection{B9}

\subsubsection{B10}

\subsubsection{B11}

\end{document}