\documentclass[a4wide, 11pt]{article}
\usepackage{a4, fullpage}
\newcommand{\tab}{\hspace*{2em}}
\usepackage[margin=2cm]{geometry}
\newcommand{\tx}{\texttt}

\begin{document}

\title{OS 211 \\ Task2: User Programs \\ Design Document}
\author{Francesco Di Mauro, Thomas Rooney, Alex Rozanski}
\date{\today}
\maketitle

\section{Argument Passing}
\subsection{Data Structures}
\subsubsection{A1}
Added to \tx{process.c}:
\tab \begin{verbatim}
     struct argument
     {
         char *token;
         struct list_elem token_list_elem;
     };
\end{verbatim}
\tab The struct represent an argument, which \tx{char *token} is pointing to. This struct can be added in a list struct.
\\
\tab \begin{verbatim}
     struct stack_setup_data
     {
         struct list argv;
         int argc;
         struct argument **argument_ptrs;
     };
\end{verbatim}
This struct stores the data needed to setup the stack in \tx{start\_process}, namely a list of \tx{struct argument}, the number of arguments, and a list of pointer to \tx{struct argument}, used to free the memory at the end. 

\subsection{Algorithms}
\subsubsection{A2}
Argument parsing is split between the functions \tx{process\_execute} and \tx{start\_process}. \\
At the beginning of \tx{process\_execute}, a \tx{stack\_setup\_data} struct is instantiated, initializing the \tx{argv} list and setting \tx{argc} to zero. Afterwards, the file name passed as an argument to the pintos command is tokenized, and the pointers to the single tokens are stored into a \tx{struct argument}, and then added to the \tx{argv} list. Each struct is pushed at the front of the list, so that at the end the arguments will already be in reverse order, as needed. \\
The function \tx{start\_process}, will take care of pushing the arguments on the stack. As a first thing, it will save the pointer to the name of the process, which will be needed in order to free the memory page at the end of the stack setup. Then, after setting up the interrupt frame, it will iterate over the list of arguments a first time: in this first "pass", the string representing the arguments will be copied onto the stack, modifying the location \tx{esp} is pointing to depending on the length of the string. The iteration will be from the front to the end of the list, since the arguments are already in the opposite order. Moreover, the \tx{char} pointers pointing to the arguments in the heap, will be substituted with the location the \tx{esp} is pointing to. The function will then push a \tx{uint8\_t} as a word alignment, and a \tx{NULL} pointer, in order to respet the convention that \tx{argv[argc] = NULL}. Afterwards, the function will iterate over the same list again, this time pushing the pointers to the strings in the same (opposite) order. Finally, the pointer to the first argument will be pushed, followed by \tx{argc} and the "fake" return address.   

\subsection{Rationale}
\subsubsection{A3}


\section{System Calls}
\subsection{Data Structures}
\subsubsection{B1}

\subsubsection{B2}

File descriptors are associated with open files through a hash table. Each process's thread stores a hash table which associates file descriptors with \tx{struct file\_descriptor}s. \tx{struct file\_descriptor} stores a \tx{struct file} pointer which can then be used with the file and filesystem kernel functions.

File descriptors are unique within a single process, as there is no need for them to be unique within the entire OS since they only identify open files at the process level.

\subsection{Algorithms}
\subsubsection{B3}

\subsubsection{B4}

\subsubsection{B5}

\subsubsection{B6}

\subsection{Synchronisation}
\subsubsection{B7}

\subsubsection{B8}

\subsection{Rationale}
\subsubsection{B9}

\subsubsection{B10}

As we use a hash table, our implementation of file descriptors is very efficient for lookup, which is an $O(1)$ operation (the hash function is just the identity function). It is also space efficient, as it is a dynamically sized data structure which optimises for space efficiency.

However, our implementation uses a single hash table per process, which requires more memory than if we only used a single hash table which was shared between all processes.

\subsubsection{B11}

\end{document}